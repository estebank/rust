// Warn when we encounter a manual `Default` impl that could be derived.
//@ run-rustfix
#![allow(dead_code)]
#![deny(default_could_be_derived)]
#![feature(default_field_values)]

#[derive(Debug)]
#[derive(Default)] struct A;


#[derive(Debug)]
#[derive(Default)] struct B(Option<i32>);


#[derive(Debug)]
#[derive(Default)] struct C(Option<i32>);



// Explicit check against numeric literals and `Default::default()` calls.
#[derive(Default)] struct D {
    x: Option<i32>,
    y: i32,
}


// Explicit check against `None` literal, in the same way that we check against numeric literals.
#[derive(Debug)]
#[derive(Default)] struct E {
    x: Option<i32>,
}


// Detection of unit variant ctors that could have been marked `#[default]`.
#[derive(Default)] enum F<T> {
    #[default] Unit,
    Tuple(T),
}


// Comparison of `impl` *fields* with their `Default::default()` bodies.
#[derive(Default)] struct G {
    f: F<i32>,
}


// Always lint against manual `Default` impl if all fields are defaulted.
#[derive(PartialEq, Debug)]
#[derive(Default)] struct H {
    x: i32 = 101,
}


// Always lint against manual `Default` impl if all fields are defaulted.
#[derive(PartialEq, Debug)]
#[derive(Default)] struct I {
    x: i32 = 101,
    y: Option<i32>,
}


// Account for fn calls that are not assoc fns, still check that they match between what the user
// wrote and the Default impl.
#[derive(Default)] struct J {
    x: K,
}


struct K;

impl Default for K { // *could* be derived, but it isn't lintable because of the `foo()` call
    fn default() -> Self {
        foo()
    }
}

fn foo() -> K {
    K
}

// Verify that cross-crate tracking of "equivalences" keeps working.
#[derive(PartialEq, Debug)]
#[derive(Default)] struct L {
    x: Vec<i32>,
}


fn main() {
    let _ = A::default();
    let _ = B::default();
    let _ = C::default();
    let _ = D::default();
    let _ = E::default();
    let _ = F::<i32>::default();
    let _ = G::default();
    assert_eq!(H::default(), H { .. });
    let _ = I::default();
    let _ = J::default();
    let _ = K::default();
    let _ = L::default();
}
