// Warn when we encounter a manual `Default` impl that could be derived.
//@ run-rustfix
#![allow(dead_code)]
#![deny(default_could_be_derived)]
#![feature(default_field_values)]

// #[derive(Debug)]
// struct A;
// 
// impl Default for A {
//     fn default() -> Self { A }
// }
// 
#[derive(Debug)]
#[derive(Default)] struct B(Option<i32>);


#[derive(Debug)]
#[derive(Default)] struct C(Option<i32>);



// Explicit check against numeric literals and `Default::default()` calls.
#[derive(Default)] struct D {
    x: Option<i32>,
    y: i32,
}


// Explicit check against `None` literal, in the same way that we check against numeric literals.
#[derive(Debug)]
#[derive(Default)] struct E {
    x: Option<i32>,
}


// Detection of unit variant ctors that could have been marked `#[default]`.
#[derive(Default)] enum F<T> {
    #[default] Unit,
    Tuple(T),
}


// Comparison of `impl` *fields* with their `Default::default()` bodies.
#[derive(Default)] struct G {
    f: F<i32>,
}


// Always lint against manual `Default` impl if all fields are defaulted.
#[derive(PartialEq, Debug)]
#[derive(Default)] struct H {
    x: i32 = 101,
}


// Always lint against manual `Default` impl if all fields are defaulted.
#[derive(PartialEq, Debug)]
#[derive(Default)] struct I {
    x: i32 = 101,
    y: Option<i32>,
}


fn main() {
//    let _ = A::default();
//    let _ = B::default();
//    let _ = C::default();
    let _ = D::default();
    let _ = E::default();
    let _ = F::<i32>::default();
    let _ = G::default();
    assert_eq!(H::default(), H { .. });
}
